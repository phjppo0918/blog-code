# 토이프로젝트에 헥사고날을 적용해보았다

근래 진행한 Dokbaro 서비스에서 백엔드 아키텍처를 헥사고날을 기반으로 설계하였습니다.   
헥사고날 아키텍처를 선택한 배경은 무엇이고, 어떠한 점을 느꼈는지 지금부터 알아보도록 하겠습니다.  

# DOKBARO란??
자기계발과 성장을 위해 독서와 스터디를 활용하는 **개발자들을 위한 퀴즈 학습 플랫폼, DOKBARO**입니다.

개발 서적을 즐겨 읽지만, **매번 내용을 제대로 이해했는지 확인하기 어렵지 않으셨나요?** 혹은 이해 부족으로 인해 **독서 스터디가 소수만 적극적으로 참여하는 형태로 변질되는 경험**을 하셨을지도 모릅니다.

그래서, **DOKBARO는**

📚 **퀴즈 출제 및 풀이 기능**으로 도서 내용을 재미있고 효과적으로 이해하도록 도와드려요.

💡 **스터디 리포트 기능**으로 스터디원들이 책에 대해 자유롭게 의견을 나누고, 서로의 학습 현황을 확인할 수 있어요.

**DOKBARO와 함께라면** 도서 이해도를 높이고, 스터디 활동을 보다 풍성하고 활발하게 만들어 이상적인 독서 환경을 경험하실 수 있습니다. ✌️

현재는 알파테스트 중에 있으니, 조금만 더 보완해서 여러분들께 선사하도록 하겠습니다!

# 레이어드 아키텍처의 역린(逆鱗)

레이어드 아키텍처의 가장 큰 문제는 도메인이 인프라에 종속된다는 점입니다.   
통상적으로 우리가 객체를 설계할 떄 행위를 기반으로 설계를 하고, 행위를 기반으로하는 상태를 결정하는 것이 일반적이라 생각합니다.

> 객체가 적합한지를 결정하는 것은 상태가 아니라 행동이다. 행동이 상태를 결정한다.  
> _객체지향 사실과 오해 - 조영호 -_

허나, DB는 상태(데이터) 만 저장하지 메서드(행위)를 저장하지 않습니다. 객체와 데이터가 바라보는 관점이 다른데, 이 둘을 통합할 수 있을까요?  
객체의 변경 주기를 DB가 따라갈 수 있을까요?  

물론 JPA와같은 ORM을 이용해서 이러한 간극을 줄일 수 있습니다. 허나, ORM을 통해서 객체를 원하는대로 설계할 수 있을까요?  
JPA가 많은 API를 제공한다 하지만, 일부 케이스에서 표현을 못하는 부분은 분명 존재합니다.

객체와 데이터의 간극을 어떻게 대응할 수 있을까요?  
이러한 질문에서 나온 해결책 중 하나가 헥사고날 아키텍처입니다.

# 헥사고날 아키텍처란?
헥사고날 아키텍처는 시스템 내부 로직과 외부 로직을 분리하여 변경에 유연한 아키텍처입니다.  
내부 로직에 대해 접근할 수 있는 부분을 인터페이스로 표현하고 (포트)  
외부에서 통신하는 시스템을 (어댑터) 포트와 연결하여 사용하는 구조입니다.  
그렇기 때문에 포트-어댑터 아키텍처라고도 합니다 (개인적으로 이 네이밍이 헥사고날보다 더 와닿네요)  
인터페이스로 외부와 격리를 했기에 Core 내부에서는 순수한 도메인 로직을 가질 수 있게 됩니다.

위 설명드린 아키텍처를 기반으로 DOKBARO는 다음과 같이 애플리케이션을 구성하였습니다.  
![img.png](img.png)

# 장점
헥사고날을 기반으로 개발하였을 때 느꼈던 장점을 설명드리겠습니다.

## 1. 표현의 자유를 쟁취했다.
일단 DB에 종속되지 않으니 내부 state 값을 자유롭게 표현할 수 있었습니다.  
데이터를 신경쓰지 않고 객체를 설계하다보니 더욱 견고한 도메인을 만들 수 있었던 것 같습니다.

## 2. 유닛 테스트가 너무 쉬웠어요
외부 로직과의 의존을 끊었기에 도메인 로직의 유닛 테스트가 매우 쉽게 느꼈습니다.  
특히 Dokbaro에서는 퀴즈 만들기 / 퀴즈 풀기 로직이 매우 복잡하였는데, 그럼에도 불구하고 테스트 하기에 어렵지 않았네요!

## 3. 인프라가 변경되어도 도메인은 알 바가 아니야
중간중간 DB단에서 변경되는 케이스가 많이 있었는데요! (테이블 구조 변경, 저장 타입 변경 등)  
도메인 로직에서는 변경이 전이되는 케이스가 하나도 없었습니다!

## 4. 변경 전파가 적으니 리팩터링이 쉬워요!
port 단위로 인터페이스를 다 분리해놔서 application 내 service 로직에서 메서드 단위 이동을 해도,  
그와 연관된 로직들에 대한 변경이 없거나 매우 적었습니다

# 단점
장점만 있었으면 세상 모든 애플리케이션이 헥사고날을 기반으로 설계되었을겁니다.  
그럼 어떤 단점을 느꼈는지 나열하겠습니다.  

## 1. 복잡하다... 내 마음도 복잡해진다
구조가 매우 복잡하다는게 큰 단점입니다.  
단순히 CRUD를 짜도 input / output port 인터페이스 만들고, input / output Adapter 만들고, 애플리케이션 로직 수정하고, 도메인 수정하고...  
쉬운걸 쉽게 넘어가지 못하는 치명적인 단점이 있습니다. 
## 2. 어댑터가 보통 하나만 있는데? 그러면 레이어드랑 다를것이 뭐야?
간단한 로직인 경우에 헥사고날 아키텍처가 두각이 되지 않는 단점이 있습니다.  
controller -> service -> repository를 그냥 인터페이스만 나눠서 분리 조치한 것으로만 보이거든요 ㅠㅠ  
빈약한 도메인일수록 오히려 불필요한 추상화를 야기하게 느껴지는 단점이 있습니다.

# 총평

솔직한 생각으로는 도메인 로직이 단순할수록 생각보다 비효율적이라고 생각합니다.  
단순한 CRUD여도 수많은 클래스들을 생성하는 것을 보고 이게 맞나...라고 많이 느꼈거든요!
허나, 복잡한 로직일수록 헥사고날의 강점을 두각할 수 있었습니다.  

인프라에 대해 신경쓰지 않고 순수한 객체만으로 로직을 작성하니 구현 측면해서는 훨씬 용이하게 느껴졌으니까요!
하지만 이러한 부분도 레이어드여서도 추상화만 잘 관리하면 충분히 도메인 격리가 가능할 것 같긴 한데요... 헥사고날의 장점을 느끼기에는 아직 서비스의 성숙도가 낮은 것 같습니다.

그럼 언제 헥사고날이 용이할까요?
개인적인 생각으로는 input/output adapter가 종류가 많은 케이스, 혹은 변경이 많은 케이스에서 헥사고날의 이점을 극대화할 수 있을 것 같습니다.  
또한, 굳이 모든 도메인에 같은 아키텍처를 가져갈 필요도 없는 것 같아요! 각 도메인에 맞게 적절한 아키텍처를 사용하여 구조화하는 것이 맞다 판단됩니다!

# 결론
내가 이 프로젝트에서 헥사고날을 적용한 것은 일장일단이 있다 생각합니다. 통일성이랍시고 모든 도메인에 헥사고날을 적용한게 도리어 개발에 대한 복잡도만 높인것이 아닐까 싶네요 ㅠㅠ    
허나 이점을 취한 부분도 분명히 존재합니다! 다음에 개발을 임할때는 도메인 별로 이점을 극대화하는 방향으로 유연한 설계를 가져가지 않을까 싶습니다.

틀을 맞춰 개발한다기 보다는 구현을 하면서 점진적으로 설계해나가서 아키텍처를 확장해도 좋은 방식인 것 같아요!  
도메인의 복잡도, 팀의 전략에 따라서 아키텍처도 유연하게 가져가야한다고 생각합니다.  
은총알은 없습니다. 허나, 최선은 있습니다. 모두들 개발하실 때 최선의 판단으로 개발하시길 응원드리겠습니다. 긴 글 읽어주셔서 감사합니다.
