# SOLID 원칙은 꼭 지켜야 할까?
옛날에 사내 OO님의 발표 중에 이러한 내용이 있었습니다.

SOLID는 객체지향에서 **"반드시 지켜야할"** 5개의 규칙이다

허나,곰곰히 생각해본 결과 내 생각에는 상반되는 부분이 많이 있었습니다.  
solid 원칙을 취했을 때, 분명 잃는 부분이 있다고 항상 생각했었거든요.  
그래서 이참에 SOLID 원칙에 대해 한번 정리해보고, 제 생각을 기록해보고자 합니다.  

# SOLID 원칙이란?
solid 원칙에 대해 간단하게 살펴보겠습니다.  
이 원칙은 로버트 C. 마틴이 명명한 것으로, 소프트웨어의 확장 및 유지보수가 쉽게 하기 위한 지침입니다!

#### S - SRP : 단일 책임 원칙
- 하나의 클래스는 하나의 책임만 가져야 한다.
#### O - OCP : 개방 폐쇄 원칙
- 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
#### L - LSP : 리스코프 치환 원칙
- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 한다.
- 상위 타입을 하위 타입 객체로 대체하여도 정상적으로 동작하여야한다. 

#### I - ISP : 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여라개가 범용 인터페이스 보다 낫다

#### D - DIP : 의존성 역전 원칙
추상화에 의존해야지 구체화에 의존하면 안 된다.

# 이렇게 좋은 원칙을 우리 회사는 왜 안지킬까
위 설명만 얼핏 보면 무조건 지켜야 하는 것 처럼 보입니다.  
하지만 SOLID 원칙이 은탄환이면 모든 회사가 지키고 있겠죠...?  
분명 그에 상응하는 고려해야 할 부분이 있을 겁니다! 그럼 어떤 부분에 있어 고려하면 좋을지 알아볼까요??

# 우리는 어디까지 분리할 것인가?
SRP / ISP를 지키면 클래스간 결합도가 낮아져 유지보수가 용이해질 것입니다.  
허나, 많은 클래스와 인터페이스가 주구장창 생기겠죠?? 클래스가 많아지니, 관계가 많아지는 것도 덤이고요.  
결국 관리 포인트가 늘어난다는 단점이 있습니다.  
무조건 메서드 단위로 다 분리하는 것 보다, 변경 주기가 같은 요소끼리 그룹화하여 클래스 및 인터페이스를 설계해야하지 않나 싶습니다.

# 우리는 어디까지 추상화 할 것인가? 무엇에 의존할 것인가?
OCP / DIP / LSP 이 세가지 원칙은 추상화를 통해 의존을 역전 시켜 유연함을 향상한다는 것을 기반으로 두고 있습니다.  
허나, 우리는 무엇에 의존해야 하는지 고민해볼 필요가 있습니다.  
의존이 나쁜건가요? 의존은 다 분리해야하는 건가요?
개발 시 Spring / node 같은 프레임워크에는 의존하지 않는 건가요?  
JAVA / Koltin 같은 언어에는 의존하지 않는 건가요? 
결국 우리는 어떠한 것에 의존을 하면서 개발을 할 수 밖에 없습니다. 의존성을 100% 없애기란 불가능하다 생각합니다.  
그럼 우리는 무엇에 의존해야 할까요? 제 생각에는 변하지 않는 것에 의존해야 한다 생각합니다.  
개발할 때 타 프레임워크에 전환을 고려해서 Spring에 관련한 의존성을 다 추상화해서 분리한다 생각해보세요! 상상만 해도 복잡하지 않나요?  
클래스도 마찬가지 입니다. Service / repository 컴포넌트가 하나만 존재한다면, 굳이 추상화할 필요가 있을까요?  
정말로 유연성이 필요한 부분만 추상화를 진행하는 것이 맞다 생각합니다.
어설픈 추상화는 도리어 유지보수 하기 힘들다 생각하기 때문에, 막연히 추상화를 진행하는 것 보다는 현 애플리케이션 상황에 맞게 추상 정도를 조절하는 것이 더 유용하지 않나 싶습니다.  
추가저으로로 SOLID 원칙 중에서, 다른건 몰라도 LSP 만큼은 필수로 지켜야 하지 않나 생각이 되는데요, LSP 를 위반할 바에 추상화를 진행하지 않는 것이 더 맞다 생각합니다.

# 결론
개발에서는 결국 은탄환이란 없습니다. 즉 SOLID 원칙도 필수로 지켜야한다는 것이라 생각하지는 않습니다.  
"우리 서비스가 점진적으로 성장하다 보니 SOLID 원칙을 기반으로 가고 있어!" 가 맞는 것이지,  
처음부터 "우리 서비스는 SOLID 원칙을 필수로 지키며 나아가" 는 생각보다 그 가치를 누리기 어렵다 생각합니다.  
도구를 의존하는 개발자는 도구를 이용하는 개발자를 넘어설 수 없다 생각합니다.  
긴 글 읽어주셔서 감사합니다.